"""Webhook server for GitHub integration"""

import asyncio
import hashlib
import hmac
import json
import logging
from typing import Dict, Any, Optional
from fastapi import FastAPI, Request, HTTPException, BackgroundTasks
from fastapi.responses import JSONResponse
from contextlib import asynccontextmanager

from src.core.config import get_settings
from src.services.agent import ClaudeAgent
from src.services.task_queue import TaskQueue
from src.utils.logging import get_logger


logger = get_logger(__name__)


class WebhookServer:
    """GitHub Webhook server"""
    
    def __init__(self):
        self.settings = get_settings()
        self.agent = ClaudeAgent()
        self.task_queue = TaskQueue()
        self.webhook_secret = self.settings.github_token  # Use as webhook secret for PoC
        
    def verify_signature(self, payload: bytes, signature: str) -> bool:
        """Verify GitHub webhook signature"""
        if not signature.startswith('sha256='):
            return False
        
        expected_signature = hmac.new(
            self.webhook_secret.encode('utf-8'),
            payload,
            hashlib.sha256
        ).hexdigest()
        
        received_signature = signature[7:]  # Remove 'sha256=' prefix
        return hmac.compare_digest(expected_signature, received_signature)
    
    async def handle_issue_event(self, payload: Dict[str, Any], background_tasks: BackgroundTasks) -> Dict[str, Any]:
        """Handle GitHub issue events"""
        action = payload.get('action')
        issue = payload.get('issue', {})
        repository = payload.get('repository', {})
        
        if action == 'opened':
            # Create task for new issue
            issue_number = issue.get('number')
            repo_name = repository.get('full_name')
            
            if issue_number and repo_name:
                logger.info(f"New issue #{issue_number} opened in {repo_name}")
                
                # Add to task queue for processing
                background_tasks.add_task(
                    self._process_issue_async,
                    issue_number,
                    repo_name
                )
                
                return {"status": "queued", "issue": issue_number, "repo": repo_name}
        
        elif action == 'labeled':
            # Check if issue was labeled with automation trigger
            label = payload.get('label', {})
            if label.get('name') in ['claude-code', 'auto-implement']:
                issue_number = issue.get('number')
                repo_name = repository.get('full_name')
                
                logger.info(f"Issue #{issue_number} labeled for automation in {repo_name}")
                
                background_tasks.add_task(
                    self._process_issue_async,
                    issue_number,
                    repo_name
                )
                
                return {"status": "queued", "issue": issue_number, "repo": repo_name}
        
        return {"status": "ignored", "action": action}
    
    async def handle_pull_request_event(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Handle GitHub pull request events"""
        action = payload.get('action')
        pr = payload.get('pull_request', {})
        
        if action == 'closed' and pr.get('merged'):
            # Handle merged PR
            pr_number = pr.get('number')
            repo_name = payload.get('repository', {}).get('full_name')
            
            logger.info(f"PR #{pr_number} merged in {repo_name}")
            
            # Update task status if it's our PR
            task_id = self._extract_task_id_from_pr(pr)
            if task_id:
                try:
                    task = self.agent.get_task_status(task_id)
                    if task:
                        self.agent.state_manager.update_task_status(task_id, "completed")
                        logger.info(f"Task {task_id} marked as completed")
                except Exception as e:
                    logger.error(f"Failed to update task status: {e}")
        
        return {"status": "processed", "action": action}
    
    def _extract_task_id_from_pr(self, pr: Dict[str, Any]) -> Optional[str]:
        """Extract task ID from PR body"""
        import re
        
        body = pr.get('body', '')
        if not body:
            return None
        
        # Look for task ID patterns
        patterns = [
            r'Task ID:\s*([a-zA-Z0-9-]+)',
            r'task-id:\s*([a-zA-Z0-9-]+)',
            r'Generated by.*task-([a-zA-Z0-9-]+)'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, body, re.IGNORECASE)
            if match:
                return match.group(1)
        
        return None
    
    async def _process_issue_async(self, issue_number: int, repo_name: str):
        """Process issue asynchronously"""
        try:
            # Create task
            task_id = self.agent.create_task_from_issue(issue_number, repo_name)
            
            # Add to task queue
            await self.task_queue.add_task(task_id, priority="medium")
            
            logger.info(f"Task {task_id} queued for issue #{issue_number}")
            
        except Exception as e:
            logger.error(f"Failed to process issue #{issue_number}: {e}")


# Global webhook server instance
webhook_server = WebhookServer()

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manage application lifespan"""
    # Startup
    logger.info("Starting webhook server...")
    await webhook_server.task_queue.start()
    
    yield
    
    # Shutdown
    logger.info("Stopping webhook server...")
    await webhook_server.task_queue.stop()

# Create FastAPI app
app = FastAPI(
    title="Claude Code Cluster Webhook Server",
    description="GitHub webhook handler for automated code generation",
    version="0.1.0",
    lifespan=lifespan
)

@app.get("/")
async def root():
    """Root endpoint"""
    return {"message": "Claude Code Cluster Webhook Server", "status": "running"}

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "webhook-server"}

@app.post("/webhook/github")
async def github_webhook(request: Request, background_tasks: BackgroundTasks):
    """GitHub webhook endpoint"""
    
    # Get signature
    signature = request.headers.get('X-Hub-Signature-256')
    if not signature:
        raise HTTPException(status_code=400, detail="Missing signature")
    
    # Get payload
    payload_bytes = await request.body()
    
    # Verify signature
    if not webhook_server.verify_signature(payload_bytes, signature):
        raise HTTPException(status_code=401, detail="Invalid signature")
    
    # Parse payload
    try:
        payload = json.loads(payload_bytes.decode('utf-8'))
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid JSON payload")
    
    # Get event type
    event_type = request.headers.get('X-GitHub-Event')
    
    try:
        if event_type == 'issues':
            result = await webhook_server.handle_issue_event(payload, background_tasks)
        elif event_type == 'pull_request':
            result = await webhook_server.handle_pull_request_event(payload)
        elif event_type == 'ping':
            result = {"status": "pong"}
        else:
            result = {"status": "ignored", "event": event_type}
        
        return JSONResponse(content=result)
        
    except Exception as e:
        logger.error(f"Webhook processing error: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@app.get("/webhook/status")
async def webhook_status():
    """Get webhook server status"""
    queue_status = await webhook_server.task_queue.get_status()
    
    return {
        "status": "running",
        "queue": queue_status,
        "settings": {
            "webhook_secret_configured": bool(webhook_server.webhook_secret)
        }
    }

if __name__ == "__main__":
    import uvicorn
    settings = get_settings()
    uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")